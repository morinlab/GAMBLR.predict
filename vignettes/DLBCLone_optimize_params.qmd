---
title: "DLBCLone Functions â€” Optimizing Parameters"
vignette: >
  %\VignetteIndexEntry{quarto vignettes}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
from: markdown+emoji
fig.align: "center"
---

```{r set working directory and libs, echo=FALSE, include=FALSE, cache=FALSE}
library(GAMBLR.predict)
library(tidyverse)

all_full_status <- readr::read_tsv(system.file("extdata/all_full_status.tsv",package = "GAMBLR.predict")) %>%
  tibble::column_to_rownames("sample_id")

default_model <- "best_opt_w"

loaded_model <- DLBCLone_load_optimized(
        dirname(
            system.file(
                "extdata/models",
                "best_opt_model.rds",
                package = "GAMBLR.predict"
            )
        ),
        default_model
    )

all_features_optimized <- DLBCLone_activate(loaded_model, force = TRUE)
```

# DLBCLone_optimize_params 

This function sets multiple tuning thresholds based on the structure of the training data provided. On the training, it handles predictions, applies thresholding, and makes data-driven approximations for classifying samples using UMAP embeddings and k-nearest neighbor logic.

`combined_mutation_status_df` feature matrix data frame with one row per sample and one column per mutation

`metadata_df` data frame of metadata with one row per sample and three required columns: sample_id, dataset and lymphgen

`umap_out` the output of a previous run of `make_and_annotate_umap`

`truth_classes` vector of classes to use for training and testing (LymphGen default: c("EZB", "MCD", "ST2", "N1", "BN2", "Other"))

`optimize_for_other` set to TRUE to optimize the threshold for classifying samples as "Other" based on the relative proportion of samples nearest to the sample in the UMAP space with an "Other" label. Rather than treating Other as just another class, this will optimize the threshold for a separate score that considers how many Other and non-Other samples are in the neighborhood of the sample in question. This parameter will NOT change the value in predicted_label. Instead, the predicted_label_optimized column will contain the optimized label (default: FALSE)

`min_k` starting k for knn (default: 3)

`max_k` ending k for knn (default: 33)

# Example 1 Optimize for other TRUE 

Let's assume we are generally happy with the separation of samples in this latent representation. We can use `DLBCLone_optimize_params` to pick a combination of k (number of neighbors) and a few thresholds to categorize each sample based on its location and proximity to other points in the UMAP. Here, we give the original UMAP produced by `make_and_annotate_umap` and not the repojected UMAP, because this function will perform the sample-by-sample projection for us. Optimize for other will be set to TRUE as we are interested in high confidence predictions that are less likely to actually be "Other".

```{r optimize1, eval=FALSE}
all_features_optimized = DLBCLone_optimize_params(  
  mu_everything$features, 
  dlbcl_meta_clean,
  umap_out = mu_everything,
  truth_classes = c("MCD","EZB","BN2","N1","ST2","Other"),
  optimize_for_other = T,
  min_k=5,
  max_k=13
)
```
```{r, message=FALSE, warning=FALSE}
knitr::kable(all_features_optimized$best_params)
```

## Overview of classifications, Example 1 

### posthoc_feature_enrichment 

Interested in the most contributing mutations per subtype? Whether it be the most frequently mutated, or the most significantly mutated via chi square subtype vs. rest? `posthoc_feature_enrichment` can help evaluate structure and potential biases in your training data. Bar and/or forest plots can be produced.

`sample_metadata` Data frame containing sample metadata with class labels, by default in a column named "lymphgen". Use `label_column` to specify a different column

`features` Feature matrix with one row per sample and one column per mutation feature

`label_column` Name of the column containing the class labels (default: "lymphgen")

`truth_classes` Vector of class labels to consider (default: c("BN2","EZB","MCD","ST2","N1"))

`method` Method to determine top features: "frequency" for most abundant features, "chi_square" for top differentially mutated features in the classes vs all other classes (default : "frequency")

`num_feats` Number of top features to display per subtype (default: 10)

`separate_plot_per_group` If TRUE, creates separate plots for each group and also combines them with ggarrange (default: FALSE).

`title` Title for the plot (default: NULL)

`p_threshold` Maximum P value to retain (when method is fisher)

`base_size` Base font size used (passed to theme_Morons) 

```{r, message=FALSE, warning=FALSE}
plots<- posthoc_feature_enrichment(
  sample_metadata = all_features_optimized$predictions,
  features = all_features_optimized$features,
  method = "frequency"
)
```
```{r, message=FALSE, warning=FALSE}
plots$bar_plot
```
```{r, message=FALSE, warning=FALSE}
plots$forest_plot
```

### basic_umap_scatterplot 

A more advanced plotting function for the UMAP projections. This function can also cover predicted columns of your choosing.

`optimized` data frame containing at least V1, V2, sample_id, and grouping columns

`plot_samples` Optional character vector of sample_id's to label in the plot

`colour_by` column name to color points by (default: `truth_column`)

`truth_column` name of the truth/ground-truth column

`pred_column`  name of the predicted-class column

`other_label`  label used for the outgroup/unclassified class

`title` plot title

`use_plotly` if FALSE and `plot_samples` provided, draw static 

`custom_colours` custom color palette for the plot. If not provided, uses default GAMBL colors

```{r, message=FALSE, warning=FALSE,results='hide'}
basic_umap_scatterplot(
  all_features_optimized$prediction, 
  colour_by = "lymphgen",
  pred_column = "lymphgen",
  title = "truth"
)
```

### make_alluvial 

Plotting function `make_alluvial` generates detailed alluvial plots to visualize the concordance and discordance between original (e.g., Lymphgen) and predicted (e.g., DLBCLone) class assignments for samples.

`optimized` output from DLBCLone_optimize_params function

`pred_column` name of the column in predictions to use for the predicted class 

`pred_name` name for the predicted class column 

DLBCLone with outgroup optimization ("wo") w for weighted, o for optimized for other.
```{r plot_alluvial2, message=FALSE, warning=FALSE,results='hide'}
make_alluvial(all_features_optimized,pred_column = "DLBCLone_wo",pred_name = "DLBCLone_wo")
```

```{r, message=FALSE, warning=FALSE,results='hide'}
basic_umap_scatterplot(
  all_features_optimized_T$prediction, 
  colour_by = "DLBCLone_wo",
  pred_column = "DLBCLone_wo",
  title = "DLBCLone_wo"
)
```

### DLBCLone_summarize_model 

Generates and saves a set of summary plots as PDF, and tables for a DLBCLone model in a preallocated folder. This summary includes; UMAP scatterplots, alluvial plots, and oncoplots.

```{r, message=FALSE, warning=FALSE, eval = FALSE}
DLBCLone_summarize_model(
  optimized_model = all_features_optimized_T,
  base_name="model_summaries/all_full_status"
)
```

# Example 2 Optimize for other FALSE 

When looking at w for weighted, not wo for weighted and optimized for other, DLBCLone outputs its greedy search strategy, aiming to classify as many samples as possible, even at low confidence levels. This approach can reveal trends in the underlying data structure, but it also increases the risk of assigning low-confidence predicted labels.

DLBCLone without outgroup optimization ("w") w for weighted.

```{r, message=FALSE,warning=FALSE,results='hide'}
make_alluvial(all_features_optimized,pred_column = "DLBCLone_w",pred_name = "DLBCLone_w")
```

```{r, message=FALSE, warning=FALSE,results='hide'}
basic_umap_scatterplot(
  all_features_optimized$prediction, 
  colour_by = "DLBCLone_w",
  pred_column = "DLBCLone_w",
  title = "DLBCLone_w"
)
```

# DLBCLone_ensemble_postprocess 

This is an optional function you can run after `DLBCLone_optimize_params`. it will post-process KNN results across K to score consistency, optionally refine classified/Other cutoffs per-class and can assign composite classes. This is a more complex approach that may yield better results but is not yet fully validated.

`optimized_model` output of DLBCLone_optimize_params

`other_min` for comparing across a range of K values, this is the threshold for the number of K values a sample is classified as Other for it to be re-assigned as Other. Set this to a high value if you don't want samples to be reassigned at all

`assign_composites` if TRUE: samples with split votes across multiple in-group classes will be assigned a composite class (e.g. "EZB/MCD") instead of "Other"

`any_split` if TRUE: any split among in-group votes across the Ks tested will triggers reassignment (or composite)

`optimize_per_class` if TRUE: a range of thresholds will be tested per class to optimize the classification/Other cutoff

```{r, message=FALSE, warning=FALSE}

postprocess_params <- DLBCLone_ensemble_postprocess(
  optimized_model = all_features_optimized,
  other_min = 3,
  assign_composites = TRUE,
  any_split = TRUE,
  optimize_per_class = TRUE
)

```

