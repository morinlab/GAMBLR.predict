---
title: "Applying a DLBCLone model to new data"
vignette: >
  %\VignetteIndexEntry{quarto vignettes}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
from: markdown+emoji
fig.align: "center"
---

## Preamble

This guide will demonstrate the steps for training a custom DLBCLone model and applying it to classify new samples. 


## Preparing your *test* data

To use a trained DLBCLone model on your data, you need (at a minimum) either a MAF file or a mutation status matrix for the genes (features) that were used to generate the model. Here, you will learn how to generate a mutation status matrix using one of our published cohorts, which was sequenced with the LySeqST panel. If you have translocation status for BCL2, BCL6 etc and want to include that in the model, you will also need a second table that includes the translocation status for each sample. We generally refer to this as the metadata table. Together, your MAF and metadata files will be used to assemble the feature matrix that will be used for UMAP and KNN approximation on your samples. 


### SV status

For this example, we will extract the BCL2 and BCL6 status directly from the output of LymphGen. We will also use the LymphGen classification to evaluate our accuracy. Importantly, you do not need a LymphGen result from your *test* data but it can be useful to sanity check your UMAP and your model performance. The MAF and metadata for these samples (in the form of a LymphGen output) are both bundled with this package. The code below loads these files and restructures a few columns to make them compatible with downstream functions. 

```{r set working directory and libs, message = FALSE, warning = FALSE}
library(GAMBLR.open)
library(GAMBLR.utils) 
library(tidyverse)
library(GAMBLR.predict)

lymphgen_test = "extdata/lyseq_validation/LySeqST_only_unaugmented_vaf.lymphgen_calls.no_cnvs.with_sv.no_A53.tsv"
valid_metadata <- readr::read_tsv(
  system.file(lymphgen_test,package = "GAMBLR.predict")) %>%
  rename(
    sample_id = Sample.Name,
    lymphgen = Subtype.Prediction
  ) %>%
  mutate(
    BCL2.Translocation = if_else(BCL2.Translocation == "yes", "POS", BCL2.Translocation),
    BCL2.Translocation = if_else(BCL2.Translocation == "no", "NEG", BCL2.Translocation),
    BCL2.Translocation = if_else(BCL2.Translocation == "Not Available", "NA", BCL2.Translocation),
    BCL6.Translocation = if_else(BCL6.Translocation == "yes", "POS", BCL6.Translocation),
    BCL6.Translocation = if_else(BCL6.Translocation == "no", "NEG", BCL6.Translocation),
    BCL6.Translocation = if_else(BCL6.Translocation == "Not Available", "NA", BCL6.Translocation)
  )
maf_test = "extdata/lyseq_validation/LySeqST_merged_unaugmented_vaf.maf"
valid_maf_vaf_dir <- readr::read_tsv(system.file(maf_test,package = "GAMBLR.predict")) %>%  
  mutate(
    sample_id = Tumor_Sample_Barcode
  )
#convert to S3 object for compatability
valid_maf_vaf <- create_maf_data(
    maf_df = valid_maf_vaf_dir,
    genome_build = "grch37"
  ) %>%
    mutate(Chromosome = as.character(Chromosome))
```

### Synonymous mutations
If the model you're using used base-3 encoding (0,1,2), that means synonymous mutations are considered for some genes. You will have to know up-front (or find out) which genes this applies to, so you can encode your data consistently.
If your MAF file doesn't contain any synonyous mutations, be sure to use a model that was trained only on coding mutations. 


## metadata 
```{r head metadata, message = FALSE, warning = FALSE}

knitr::kable(head(valid_metadata))

```


## lyseq features 


```{r load model, echo = FALSE, message = FALSE, warning = FALSE}
lyseq_features_optimized_train <- DLBCLone_load_optimized(
        dirname(
            system.file(
                "extdata/models",
                "lyseq_opt_w_model.rds",
                package = "GAMBLR.predict"
            )
        ),
        "lyseq_opt_w"
    )

lyseq_features_optimized_train <- DLBCLone_activate(lyseq_features_optimized_train, force = TRUE)


```

The LySeqST sequencing panel includes the following genes. In order to train a classifier compatible with this panel, we need to subset the training data to ensure only these genes are included in training. 

```{r, message=FALSE, warning=FALSE,results='hide'}
lyseq_genes <- c(
  "TNFRSF14", "SPEN", "ID3", "ARID1A", "RRAGC",
  "BCL10", "CD58", "NOTCH2", "FCGR2B", "FCRLA",
  "FAS", "CCND1", "BIRC3", "ATM", "KMT2D",
  "STAT6", "BTG1", "FOXO1", "B2M", "MAP2K1",
  "IDH2", "CHD2", "CREBBP", "SOCS1", "IL4R",
  "PLCG2", "TP53", "STAT5B", "STAT3", "CD79B",
  "GNA13", "BCL2", "TCF3", "S1PR2", "JAK3",
  "MEF2B", "DNMT3A", "XPO1", "CXCR4", "SF3B1",
  "PTPN1", "XBP1", "EP300", "MYD88", "SETD2",
  "RHOA", "NFKBIZ", "TBL1XR1", "KLHL6", "TET2",
  "PIM1", "CCND3", "TMEM30A", "PRDM1", "SGK1",
  "TNFAIP3", "CARD11", "POT1", "BRAF", "EZH2",
  "UBR5", "MYC", "NOTCH1", "TRAF2", "P2RY8",
  "BTK", "TP73", "NOL9", "SEMA4A", "PRRC2C",
  "BTG2", "ITPKB", "SEC24C", "EDRF1", "WEE1",
  "MPEG1", "ETS1", "DTX1", "SETD1B", "NFKBIA",
  "ZFP36L1", "CIITA", "MBTPS1", "IRF8", "ACTG1",
  "KLHL14", "MED16", "CD70", "JUNB", "KLF2",
  "CD79A", "DYSF", "DUSP2", "BCL2L1", "PRDM15",
  "RFTN1", "OSBPL10", "EIF4A2", "BCL6", "IRF4",
  "FOXC1", "CD83", 
  "HLA-A", "HLA-B", "PRRC2A", "TBCC", "INTS1",
  "ACTB", "PIK3CG", "PRKDC", "TOX", "CDKN2A",
  "GRHPR", "DDX3X", "PIM2", "UBE2A", "ETV6",
  "MS4A1", "CD19", "HNRNPD", "NFKBIE", "TMSB4X"
)
```

## Making a compatible feature matrix

You create a mutation feature matrix with `assemble_genetic_features`. This can include mutation status and structural variant status for BCL2, BCL6, and MYC. By default, synonymous mutations will be encoded as 1 and SV and coding mutations will be encoded as 2. The genes for which synonymous mutations are considered are specified separately. The genes we commonly use are shown in the example below. 


```{r assemble, message=FALSE, warning=FALSE, results='hide'}

ashm_genes = c("ACTB","ACTG1","BCL2","BCL6","BIRC3",
     "BTG1","BTG2","CD83","CIITA","CXCR4","DDX3X",    
     "DTX1","DUSP2","ETS1","ETV6","GRHPR","ID3", 
     "IL4R","IRF4","IRF8","ITPKB","KLF2","KLHL6",
     "MEF2B","MS4A1","MYC","NFKBIZ","OSBPL10","PIM1",
     "PIM2","PTPN1","RFTN1","S1PR2","SGK1","SOCS1",
     "TMSB4X","WEE1","XBP1","ZFP36L1")

lyseq_valid = assemble_genetic_features(
  these_samples_metadata = valid_metadata,
  sv_from_metadata = c(BCL2 = 'BCL2.Translocation', BCL6 = 'BCL6.Translocation'),
  genes=lyseq_genes,
  maf_with_synon = valid_maf_vaf,
  hotspot_genes = "MYD88",
  synon_genes=ashm_genes
)
```

## Load the training data

```{r load mutations and metadata, message=FALSE, warning=FALSE, results='hide'}

all_full_status_train <- readr::read_tsv(system.file("extdata/all_full_status.tsv",package = "GAMBLR.predict")) %>%
  tibble::column_to_rownames("sample_id")

dlbcl_meta <- readr::read_tsv(system.file("extdata/dlbcl_meta_with_dlbclass.tsv",package = "GAMBLR.predict"))

dlbcl_meta_clean <- filter(dlbcl_meta,
                          lymphgen %in% c("MCD","EZB","BN2","N1","ST2","Other"))
```

Before training, the mutation matrix from the bundled training data must be subset to exclude any features that are not part of your panel. 

```{r subset, message = FALSE, warning = FALSE}
ncol(all_full_status_train)
ncol(lyseq_valid)

lyseq_train <- all_full_status_train %>%
  select(all_of(names(lyseq_valid)))

```

## Create training data UMAP

```{r umap1, message=FALSE, warning=FALSE}
mu_lyseq_train = make_and_annotate_umap(
  lyseq_train,
  dlbcl_meta_clean,
  core_features = list(
    ST2=c("SGK1","DUSP2","TET2","SOCS1"),
    N1="NOTCH1",
    EZB=c("EZH2","BCL2_SV"),
    MCD=c("MYD88HOTSPOT","CD79B","PIM1"),
    BN2=c("BCL6_SV","NOTCH2","SPEN","CD70")
  )
)
```

### Visualize UMAP

Visually confirm the separation of the training samples based on their LymphGen class labels. 

```{r, message = FALSE, warning = FALSE}
make_umap_scatterplot(mu_lyseq_train$df)
```

## Train the model

Train and optimize our model using the training data with our custom feature set. 

```{r optimize no eval, message=FALSE, warning=FALSE, eval=FALSE}
lyseq_features_optimized = DLBCLone_optimize_params(  
  mu_lyseq_train$features, 
  dlbcl_meta_clean,
  umap_out = mu_lyseq_train,
  truth_classes = c("MCD","EZB","BN2","N1","ST2","Other"),
  min_k=11,
  max_k=21
)

lyseq_features_optimized <- DLBCLone_activate( # Activates optimized model setting the UMAP projection
  lyseq_features_optimized, 
  force = TRUE
)
```

```{r optimize eval, message=FALSE, warning=FALSE, eval=TRUE, echo=FALSE}
lyseq_features_optimized = DLBCLone_optimize_params(  
  mu_lyseq_train$features, 
  dlbcl_meta_clean,
  umap_out = mu_lyseq_train,
  truth_classes = c("MCD","EZB","BN2","N1","ST2","Other"),
  min_k=19,
  max_k=19
)
```

```{r optimize activate, message = FALSE, warning = FALSE}
lyseq_features_optimized <- DLBCLone_activate( # Activates optimized model setting the UMAP projection
  lyseq_features_optimized, 
  force = TRUE
)
```

## Training accuracy

Check the classification accuracy of the optimized classifier (DLBCLone_wo) on the training data set.

```{r alluvial train, message = FALSE, warning = FALSE}

make_alluvial(lyseq_features_optimized,
  pred_column="DLBCLone_wo")

```

## Sanity check feature incidence in the *test* data

```{r predict check, message=FALSE, warning=FALSE,results='hide'}

pred_check <- DLBCLone_predict(
  mutation_status = lyseq_valid,
  optimized_model = lyseq_features_optimized,
  check_frequencies = TRUE
)

```


```{r, message = FALSE, warning = FALSE}
pred_check$plot
```

## Apply the model to the *test* data

```{r predict, message=FALSE, warning=FALSE}

pred_valid_lyseq_all <- DLBCLone_predict(
  mutation_status = lyseq_valid,
  optimized_model = lyseq_features_optimized
)

knitr::kable(head(pred_valid_lyseq_all$prediction))
```

### Sanity check the UMAP

If the UMAP is working as it should be, you should see a similar level of separation of your *test* samples in UMAP space. Since we have LymphGen classifications for our test samples, we can check this. In order to visualize these, the metadata will need to be attached to the UMAP projection of the new samples. What you should hopefully see is roughly the same placement of your samples on this scatterplot relative to the training samples. 

```{r, message = FALSE, warning = FALSE}

projected_with_meta = left_join(pred_valid_lyseq_all$projection,
select(valid_metadata,sample_id,lymphgen))
head(projected_with_meta)
unique(projected_with_meta$lymphgen)
#drop composites
projected_with_meta = filter(projected_with_meta,!grepl("/",lymphgen))

```

```{r, message = FALSE, warning = FALSE}
make_umap_scatterplot(projected_with_meta)

```

### make_neighborhood_plot 
```{r neighborhood, message = FALSE, warning = FALSE}
test_sample = "92-38267_tumorB"

make_neighborhood_plot(
  single_sample_prediction_output = pred_valid_lyseq_all,
  this_sample_id = test_sample,
  prediction_in_title = TRUE,
  add_circle = TRUE,
  label_column = "DLBCLone_wo"
)
```

### nearest_neighbor_heatmap 

```{r heatmap, message=FALSE,warning=FALSE}
nearest_neighbor_heatmap(
  this_sample_id = test_sample,
  DLBCLone_model = pred_valid_lyseq_all,
  font_size = 8
)
```

## Accuracy Assessment 

Finally, lets assess the accuracy of the validation set by comparing `dlbclone_predict` predictions with the LymphGen results that were previously generated. 

```{r compare_to_lymphgen, message=FALSE, warning=FALSE}

pred_vs_original = left_join(pred_valid_lyseq_all$prediction,valid_metadata)

#collapse composites into group-COMP
pred_vs_original = tidy_lymphgen(pred_vs_original,lymphgen_column_in = "lymphgen",lymphgen_column_out = "lymphgen_tidy")

#convert composites into their primary class
pred_vs_original = mutate(pred_vs_original,lymphgen_basic = gsub("-COMP","",lymphgen_tidy))

make_alluvial(list(predictions=pred_vs_original),
  pred_column = "DLBCLone_wo",
  group_order = c("MCD","BN2","ST2","EZB","N1","Other"),
  truth_column = "lymphgen_basic")
```

### Oncoplot

Another way to visualize the results is via an Oncoplot (using GAMBLR.viz::prettyOncoplot). 

```{r oncoplot prep, message=FALSE,warning=FALSE}
library(GAMBLR.viz)
ashm_genes = intersect(ashm_genes,lyseq_genes)

silent_show = rep("Silent",length(ashm_genes))
names(silent_show)=ashm_genes
# add hotspot annotation
valid_maf_vaf$hot_spot = NA
valid_maf_vaf = mutate(valid_maf_vaf,hot_spot=ifelse(Hugo_Symbol=="MYD88" & HGVSp_Short=="p.L265P",TRUE,FALSE))
```

```{r, message=FALSE,warning=FALSE}
prettyOncoplot(these_samples_metadata = pred_vs_original, 
  maf_df = valid_maf_vaf,
  metadataColumns = c("lymphgen_basic","DLBCLone_w","DLBCLone_wo"),
  minMutationPercent = 1,
  cluster_rows = T,
  highlightHotspots = T,
  genes = lyseq_genes,
  pctFontSize = 3,
  fontSizeGene = 3,
  hideSideBarplot = T,
  simplify_annotation = T,
  hide_annotations = c("DLBCLone_wo","DLBCLone_w"),
  include_noncoding = as.list(silent_show),
  sortByColumns = c("DLBCLone_wo","lymphgen_basic"))
```