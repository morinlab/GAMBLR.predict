---
title: "DLBCLone Functions â€” UMAP"
vignette: >
  %\VignetteIndexEntry{quarto vignettes}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
from: markdown+emoji
fig.align: "center"
---

```{r, echo = FALSE, message=FALSE, warning=FALSE, results='hide'}
library(GAMBLR.predict)
library(tidyverse)

best_opt_model_genes <- sort(c(
  "ACTB", "ACTG1", "BCL10", "BCL2", "BCL2L1", 
  "BCL6", "BIRC3", "BRAF", "BTG1", "BTG2", 
  "BTK", "CD19", "CD70", "CD79B", "CD83", 
  "CDKN2A", "CREBBP", "DDX3X", "DTX1", "DUSP2", 
  "EDRF1", "EIF4A2", "EP300", "ETS1", "ETV6", 
  "EZH2", "FAS", "FCGR2B", "FOXC1", "FOXO1", 
  "GNA13", "GRHPR", "HLA-A", "HLA-B", "HNRNPD", 
  "IRF4", "IRF8", "ITPKB", "JUNB", "KLF2", 
  "KLHL14", "KLHL6", "KMT2D", "MEF2B", "MPEG1", 
  "MYD88", "NFKBIA", "NFKBIE", "NFKBIZ", "NOL9", 
  "NOTCH1", "NOTCH2", "OSBPL10", "PIM1", "PIM2", 
  "PRDM1", "PRDM15", "PRKDC", "PRRC2C", "PTPN1", 
  "RFTN1", "S1PR2", "SETD1B", "SGK1", "SOCS1", 
  "SPEN", "STAT3", "STAT6", "TBCC", "TBL1XR1", 
  "TET2", "TMEM30A", "TMSB4X", "TNFAIP3", "TNFRSF14", 
  "TOX", "TP53", "TP73", "UBE2A", "WEE1", 
  "XBP1", "ZFP36L1", "MYD88HOTSPOT", "BCL2_SV", "BCL6_SV"
))

best_opt_model_matrix <- readr::read_tsv(system.file("extdata/all_full_status.tsv",package = "GAMBLR.predict")) %>%
  tibble::column_to_rownames("sample_id") %>%
  select(best_opt_model_genes)

dlbcl_meta <- readr::read_tsv(system.file("extdata/dlbcl_meta_with_dlbclass.tsv",package = "GAMBLR.predict"))

dlbcl_meta_clean <- filter(dlbcl_meta,
                          lymphgen %in% c("MCD","EZB","BN2","N1","ST2","Other"))
```

# make_and_annotate_umap 

This function accepts your training data as input, and will run a UMAP projection attaching the result to your metadata. This is a foundational step for running DLBCLone.

If you are not confident the UMAP is separating classes well, you can encourage better separation by assigining certain "core" genes a higher weight. This is done by specifying a vector of feature names that will have their values multiplied by 1.5. There is also a convenience option `problem_genes` to exclude/ignore certain features that are in your matrix if you think they aren't helpful. 

`df` feature matrix with one row per sample and one column per mutation

`metadata` data frame with one row per sample and a column sample_id that matches the row names of the data frame. This data frame will be joined to the UMAP output

`umap_out` insert a UMAP output from a previous run. If provided, the function will use this model to project the data instead of re-running UMAP. This is neccessary for future functions setting a static projection of UMAP coordinates that then will stay in place and not move. Run this param to ensure reproducibility of results

`core_features` a vector of column names in df that should be multiplied by core_feature_multiplier. These features are considered "core" and will be weighted more heavily in the UMAP embedding

`core_feature_multiplier` a numeric value that will be used to multiply the core features specified in core_features (default: 1.5)

`hidden_features` a vector of column names in df that should be dropped from the UMAP input. These features are considered "hidden" and will not be used in the UMAP embedding

```{r umap1}
mu_everything = make_and_annotate_umap(
  best_opt_model_matrix,
  dlbcl_meta_clean,
  core_features = list(
    ST2=c("SGK1","DUSP2","TET2","SOCS1"),
    N1="NOTCH1",
    EZB=c("EZH2","BCL2_SV"),
    MCD=c("MYD88HOTSPOT","CD79B","PIM1"),
    BN2=c("BCL6_SV","NOTCH2","SPEN","CD70")
  )
)
```

# make_umap_scatterplot 

A plotting function for the UMAP projection.

`df` data frame containing the UMAP coordinates and annotations  

`drop_composite` if TRUE: removes composite labels from the lymphgen column

`colour_by` column name to color points by

`drop_other` if TRUE: removes "Other" and "NOS" labels from the lymphgen column

`high_confidence` if TRUE: filters the data to include only samples with confidence > 0.7

`custom_colours` custom color palette for the plot. If not provided, uses default GAMBL colors

`add_labels` if TRUE: adds labels to the points based on the median coordinates of each group 

`title` Plot title

`base_size` Base font and point size for the plot (passed to theme_Morons())

`alpha` Point transparency (default: 0.8)

```{r plot1, message=FALSE, warning=FALSE}
make_umap_scatterplot(
  mu_everything$df,
  drop_other = F
)
```

```{r plot2, message=FALSE, warning=FALSE}
make_umap_scatterplot(
  mu_everything$df,
  drop_other = T
)
```

# Using a UMAP model to project the same data 

For reproducibility, future use, and faster run times, DLBCLone will re-project your umap output when optimizing parameters. As a proof of concept, we will reproject the same data using the `umap_out` paramter of `make_and_annotate_umap`. This step iteratively places each sample into the same latent space using the model generated in the last step. In this case, the location of other samples doesn't influence where each sample is placed. This is important because it means the result will be deterministic regardless of the order in which you specify samples. 

```{r project, message=FALSE}
mu_everything_proj = make_and_annotate_umap(
  mu_everything$features,
  dlbcl_meta_clean,
  umap_out = mu_everything
)

make_umap_scatterplot(
  mu_everything_proj$df,
  drop_other = F
)
```
