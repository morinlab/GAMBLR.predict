% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/umap.R
\name{DLBCLone_predict}
\alias{DLBCLone_predict}
\title{Predict class for one or more samples using a pre-trained DLBCLone model}
\usage{
DLBCLone_predict(
  mutation_status,
  optimized_model,
  mode = "DLBCLone_w",
  truth_classes = c("EZB", "MCD", "ST2", "N1", "BN2", "Other"),
  make_plot = TRUE,
  annotate_accuracy = FALSE,
  seed = 12345,
  max_neighbors = 500,
  other_class = "Other"
)
}
\arguments{
\item{truth_classes}{Vector of classes to use for training and testing. Default: c("EZB","MCD","ST2","N1","BN2")}

\item{seed}{Random seed for reproducibility}

\item{test_df}{Data frame containing the mutation status of the test sample}

\item{train_df}{Data frame containing the mutation status of the training samples}

\item{train_metadata}{Metadata for training samples with truth labels in lymphgen column}

\item{umap_out}{UMAP output from a previous run. The function will use this model to project the data, useful
for reproducibility and for using the same UMAP model on different datasets.}

\item{best_params}{Data frame from DLBCLone_optimize_params with the best parameters}

\item{other_df}{Data frame containing the predictions for samples in the "Other" class}

\item{ignore_self}{Set to TRUE to avoid considering a neighbor with the same ID
distance = 0. This is usually only relevant when re-classifying labeled
samples to estimate overall accuracy}
}
\value{
a list of data frames with the predictions, the UMAP input, the model, and a ggplot object
}
\description{
Predict class for one or more samples using a pre-trained DLBCLone model
}
\examples{

library(GAMBLR.predict)

dlbcl_meta = readr::read_tsv(system.file("extdata/dlbcl_meta_with_dlbclass.tsv",package = "GAMBLR.predict"))

all_full_status = readr::read_tsv(system.file("extdata/all_full_status.tsv",package = "GAMBLR.predict")) \%>\%
 tibble::column_to_rownames("sample_id")

make_umap <- make_and_annotate_umap(
  df=all_full_status,
  metadata=dlbcl_meta
)

optimize_params <- DLBCLone_optimize_params(  
  all_full_status, 
  dlbcl_meta,
  umap_out = make_umap,
  truth_classes = c("MCD","EZB","BN2","N1","ST2","Other"),
  optimize_for_other = T,
  min_k=5,
  max_k=23
)

predict_single <- DLBCLone_predict(
  mutation_status = optimize_params$features[1,], 
  optimized_model = optimize_params
)

}
