% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/umap.R
\name{DLBCLone_predict}
\alias{DLBCLone_predict}
\title{Predict DLBCL genetic subgroup for one or more samples using a pre-trained DLBCLone model}
\usage{
DLBCLone_predict(
  mutation_status,
  optimized_model,
  fill_missing = FALSE,
  drop_extra = FALSE,
  check_frequencies = FALSE,
  dry_run = FALSE,
  seed = 12345,
  verbose = FALSE,
  max_neighbors = 500
)
}
\arguments{
\item{mutation_status}{Data frame or matrix with one row per sample and one
column per feature (typically binary or count mutation indicators).
Row names must be unique sample IDs. Columns should correspond to the
features the model was trained on. Extra/missing features are handled by
\code{drop_extra} and \code{fill_missing}.}

\item{optimized_model}{A pre-trained DLBCLone model object as returned by
\code{DLBCLone_load_optimized()} (or saved via
\code{DLBCLone_save_optimized()}). Must contain fields such as
\code{$model} (uwot UMAP), \code{$features} (training feature matrix),
\code{$df} (training metadata incl. \code{sample_id}, \code{lymphgen}),
\code{$best_params} (e.g., \code{na_option}, \code{threshold},
\code{use_weights}), and \code{$k_DLBCLone_w}. Optional fields include
\code{$core_features}, \code{$core_feature_multiplier},
\code{$purity_DLBCLone_w}, \code{$score_thresh_DLBCLone_w}, and
\code{$truth_classes}.}

\item{fill_missing}{Logical. If \code{TRUE}, any features that exist in the
model but are absent in \code{mutation_status} are added and set to zero
for all samples (with a warning). If \code{FALSE}, missing model features
cause an error. Defaults to \code{FALSE}.}

\item{drop_extra}{Logical. If \code{TRUE}, any features present in
\code{mutation_status} but not seen during model training are dropped
(with a message). If \code{FALSE}, extra features cause an error.
Defaults to \code{FALSE}.}

\item{check_frequencies}{Logical. If \code{TRUE}, the function does not run
prediction. Instead, it computes and returns a per-feature frequency
comparison between test and training cohorts (binary presence/absence),
along with a ggplot highlighting large deviations. Defaults to \code{FALSE}.}

\item{dry_run}{Logical. If \code{TRUE}, return the preprocessed/weighted
test feature matrix (after column alignment and any core-feature
weighting/meta-feature construction) without running projection or
classification. Defaults to \code{FALSE}.}

\item{seed}{Integer seed passed to embedding/projection steps for
reproducibility. Defaults to \code{12345}.}

\item{annotate_accuracy}{Logical. Currently unused (reserved for future
output annotations). Defaults to \code{FALSE}.}
}
\value{
A list with elements (fields may vary depending on options/model):
\itemize{
\item \code{prediction}: data frame of per-sample predictions joined to
test UMAP coordinates (\code{V1}, \code{V2}) and any vote metrics.
\item \code{projection}: data frame of projected test coordinates.
\item \code{umap_input}: the model's training feature matrix
(\code{optimized_model$features}).
\item \code{model}: the frozen UMAP model used for projection
(\code{optimized_model$model}).
\item \code{features_df}: the processed test feature matrix used for
projection/classification (rows = samples).
\item \code{df}: alias of \code{prediction} (kept for compatibility).
\item \code{metadata}: the model's training metadata (\code{optimized_model$df}).
\item \code{type}: string identifier \code{"DLBCLone_predict"}.
\item \code{unprocessed_votes}: predictions before post-processing.
\item (optional) \code{core_features}, \code{core_feature_multiplier},
\code{mutation_status}: included when core-feature weighting was applied.
}
}
\description{
Projects new samples into a frozen UMAP space from a pre-trained
DLBCLone model and assigns subtype labels with a weighted k-NN
classifier. The function aligns features between the input matrix and
the training model, optionally constructs/weights meta-features
(\verb{*_feats}) based on the model's \code{core_features}, and prevents
label leakage by excluding the test sample from its own neighbor set.
}
\details{
\strong{Feature alignment.} Columns in \code{mutation_status} must match the
model's training features. Set \code{drop_extra=TRUE} to drop unexpected
columns, and \code{fill_missing=TRUE} to add missing model columns (filled
with zero). If, after adjustment, columns do not exactly match (including
order), the function stops with an error.

\strong{Core features & meta-features.} If \code{optimized_model$core_features}
is:
\itemize{
\item a \emph{list} of feature groups, the function creates meta-features
(columns suffixed with \code{"_feats"}) as the (weighted) mean of
each group's members. When \code{core_feature_multiplier} is a list,
group-specific numeric weights are applied.
\item a \emph{character vector}, core features may be multiplicatively
up-weighted by \code{core_feature_multiplier} to match training
scale if they do not already appear weighted in the input.
}

\strong{Projection & classification.} Both training and test samples are
projected into the same frozen UMAP space (no retraining) via
\code{make_and_annotate_umap(..., umap_out=optimized_model, ret_model=FALSE)}.
For each test sample, neighbors are drawn from the projected training set
with that test sample removed to prevent self-label leakage. Labels are
assigned using \code{weighted_knn_predict_with_conf()} with
\code{k=optimized_model$k_DLBCLone_w}, confidence threshold
\code{best_params$threshold}, optional distance weighting
\code{best_params$use_weights}, and \code{max_neighbors}. The
\code{other_class} is currently fixed as \code{"Other"}.

\strong{Post-processing (optional).} If the model contains
\code{$purity_DLBCLone_w} and/or \code{$score_thresh_DLBCLone_w}, the raw
vote outputs are passed to \code{process_votes()} to derive
\code{DLBCLone_w} and \code{DLBCLone_wo} decisions using score and ratio
criteria. When available, \code{$truth_classes} are used to order/interpret
group labels.

\strong{Early-return modes.}
\itemize{
\item \code{check_frequencies=TRUE}: returns a list with a ggplot object
and a frequency deviation data frame; no projection/prediction.
\item \code{dry_run=TRUE}: returns the processed test feature matrix
(after alignment/weighting); no projection/prediction.
}
}
\section{Errors and messages}{

The function stops if feature columns cannot be reconciled (see
\code{drop_extra}, \code{fill_missing}), or if, after alignment, the column
order/identity does not exactly match the training features. Messages are
emitted when dropping/adding features or when core-feature weighting is
inferred/applied or skipped.
}

\examples{
\dontrun{
# Typical usage
model <- DLBCLone_load_optimized(path = "models", name_prefix = "DLBCLone_LySeqST")
# Inspect distribution shifts without running classification
freq_chk <- DLBCLone_predict(
  mutation_status = my_panelX_matrix,
  optimized_model = model,
  check_frequencies = TRUE
)
print(freq_chk$plot); head(freq_chk$data)

preds <- DLBCLone_predict(
  mutation_status = feat_status_LySeqST,  # rows = samples, cols = features
  optimized_model = model,
  drop_extra = TRUE,    # drop unexpected columns
  fill_missing = TRUE   # add any missing model columns as zeros
)
head(preds$prediction)


# Dry run to see the meta-features after alignment/weighting
processed <- DLBCLone_predict(
  mutation_status = my_panelX_matrix,
  optimized_model = model,
  dry_run = TRUE
)
colnames(processed)


}

}
\seealso{
\code{\link{DLBCLone_load_optimized}}, \code{\link{DLBCLone_save_optimized}},
\code{\link{make_and_annotate_umap}}, \code{\link{weighted_knn_predict_with_conf}},
\code{\link{process_votes}}
}
