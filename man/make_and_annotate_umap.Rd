% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/umap.R
\name{make_and_annotate_umap}
\alias{make_and_annotate_umap}
\title{Run UMAP and attach result to metadata}
\usage{
make_and_annotate_umap(
  df,
  metadata,
  umap_out,
  truth_column = "lymphgen",
  core_features = NULL,
  core_feature_multiplier = 1.5,
  hidden_features = NULL,
  n_neighbors = 55,
  min_dist = 0,
  metric = "cosine",
  n_epochs = 1500,
  init = "spca",
  ret_model = TRUE,
  na_vals = "drop",
  join_column = "sample_id",
  seed = 12345,
  target_column,
  target_metric = "euclidean",
  target_weight = 0.5,
  calc_dispersion = FALSE,
  algorithm = "tumap",
  make_plot = FALSE
)
}
\arguments{
\item{df}{Feature matrix with one row per sample and one column per mutation}

\item{metadata}{Metadata data frame with one row per sample and a column sample_id that
matches the row names of df. This data frame will be joined to the UMAP output.}

\item{umap_out}{Optional UMAP output from a previous run. If provided, the function
will use this model to project the data instead of re-running UMAP. This is useful
for reproducibility and for using the same UMAP model on different datasets.}

\item{core_features}{A vector of column names in df that should be multiplied by
core_feature_multiplier. These features are considered "core" and will be weighted
more heavily in the UMAP embedding.}

\item{core_feature_multiplier}{A numeric value that will be used to multiply the
core features specified in core_features. Default is 1.5.}

\item{hidden_features}{A vector of column names in df that should be dropped from the
UMAP input. These features are considered "hidden" and will not be used in the UMAP embedding.}

\item{n_neighbors}{Passed to UMAP2. The number of neighbors to consider when calculating the UMAP embedding.}

\item{min_dist}{Passed to UMAP2. The minimum distance between points in the UMAP embedding.}

\item{metric}{Passed to UMAP2. The distance metric to use for calculating distances between points.}

\item{n_epochs}{Passed to UMAP2. The number of epochs to run the UMAP algorithm.}

\item{init}{Passed to UMAP2. The initialization method for the UMAP algorithm.}

\item{ret_model}{additional argument}

\item{na_vals}{How to deal with NA values. Two options are "drop", which
will remove all columns containing at least one NA or "to_zero", which sets
all NA to zero and leaves the column intact.}

\item{join_column}{The column name in the metadata data frame that contains the sample IDs (default sample_id).}

\item{seed}{Passed to UMAP2. The random seed for reproducibility.}

\item{target_column}{The column in the metadata that contains the target variable for classification.}

\item{target_metric}{The distance metric to use for calculating distances to the target variable.}

\item{target_weight}{The weight to assign to the target variable in the UMAP embedding. Default is 0.5.}

\item{calc_dispersion}{If TRUE, calculates the dispersion of the UMAP embedding.}

\item{algorithm}{The UMAP algorithm to use. Default is "tumap", which uses the TUMAP implementation.}

\item{make_plot}{If TRUE, creates a plot of the UMAP embedding.}
}
\description{
Run UMAP and attach result to metadata
}
\examples{

library(GAMBLR.predict)

all_full_status = readr::read_tsv(system.file("extdata/all_full_status.tsv",package = "GAMBLR.predict")) \%>\%
 tibble::column_to_rownames("sample_id")

dlbcl_meta = readr::read_tsv(system.file("extdata/dlbcl_meta_with_dlbclass.tsv",package = "GAMBLR.predict"))

make_umap <- make_and_annotate_umap(
  df=all_full_status,
  metadata=dlbcl_meta
)

}
